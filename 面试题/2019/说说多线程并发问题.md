# 多线程并发 #
学习链接： [https://mp.weixin.qq.com/s/f7iLQSnYSPs6skmcbwankQ](https://mp.weixin.qq.com/s/f7iLQSnYSPs6skmcbwankQ)

## Synchronized、volatile的原理 ##

### volatile原理 ###

作用： 如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。（即是可见性）

原理： volatile修饰的变量在生成汇编代码的时候，会产生一条**lock指令**，lock前缀的指令在多核处理器下会引发两件事情：

- 将当前处理器缓存航的数据写回到系统内存；（将数据写到系统内存）
- 这个写回内存的操作会使得在其它cpu里缓存了该内存地址的数据无效；（其他线程读取新的变更后的值）

这个使得其它cpu里数据无效又是怎么实现的呢？

cpu处理数据速度是很快的，为了提高处理速度，充分发挥cpu性能，cpu不直接跟内存进行通信，而是先将数据读入cpu高速缓存后再进行操作，但操作完不知道何时回写到内存。如果对声明了volatile的变量进行写操作，jvm就会向处理器发送一条lock前缀指令，将这个变量所在缓存行的数据写回到系统内存。但就算写回到内存，如果其它处理器缓存的还是旧值，再执行计算操作就会有问题。所以多处理器下，为了保证各个处理器的缓存是一致的，就有了一个“缓存一致性协议”，所有硬件厂商都要按照这个标准来生产硬件。具体就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存。

上面一段话的**总结**：

1. cpu不是直接操作系统内存，而是先读取到缓存中
2. 变量定义了volatile属性后，jvm才会发送指令将数据写入到内存
3. 其他cpu(线程)根据硬件厂商规矩的协议，通过嗅探检查数据是否过期，来更新直接的缓存


问题依然存在：

1.如果该数据已经在别的处理器线程被修改过了，只是没有刷新到内存，则这时候是不会重新读数据的，而是等一下直接刷新到内存，这就造成了覆盖的事情发生；

2.别的线程重新读取数据仅仅是在将变量读到了cpu缓存，还没有使用的时候才有的，一旦使用了，即使发现被修改了，也不会重新读取重新计算。

具有可见性，而又多线程不安全的问题就是这样产生的。

### synchronized原理 ###

synchronized是用java的**monitor机制**来实现的，就是synchronized代码块或者方法进入及退出的时候会生成monitorenter跟monitorexit两条命令。线程执行到monitorenter时会尝试获取对象所对应的monitor所有权，即尝试获取的对象的锁；
monitorexit即为释放锁。

　　
monitor机制是跟java对象结构相关的。HotSpot虚拟机中，**对象在内存中存储的布局可以分为三块区域**：对象头，实例数据跟对齐填充。

![](https://img2018.cnblogs.com/blog/393620/201810/393620-20181028104800177-695358795.png)

从上面的这张图里面可以看出，对象在内存中的结构主要包含以下几个部分：

**Mark Word(标记字段)**：对象的Mark Word部分占4个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。

Klass Pointer（Class对象指针）：Class对象指针的大小也是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址

**对象实际数据**：这里面包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节

对齐：最后一部分是对齐填充的字节，按8个字节填充。

其实，如果是数组对象，头信息还包括一个Array length的内容，用来记录数组长度。

　　我们看这个Mark Word,它包含对象的hashcode，分代年龄跟锁标记位3部分。具体结构如下(32位虚拟机)：

![](https://img2018.cnblogs.com/blog/393620/201810/393620-20181028104845321-893550318.png)

这么复杂的结构，跟synchronized有什么关系呢？

　　当然有关系，**synchronized就是利用以上结构来实现的，每次就是抢占上边的Mark Word**，然后修改里边各个小段的内容；然后，jdk的开发人员经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，那我们老是抢来抢去的岂不是没意义。**于是考虑进行优化，也就有了偏向锁，轻量级锁以及重量级锁的概念**。然后接下来我们来看这三种锁究竟是怎么一回事儿。


